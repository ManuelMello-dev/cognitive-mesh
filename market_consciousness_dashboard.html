<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Consciousness Monitor | Z³ Dashboard</title>
    <style>
        :root {
            --matrix-green: #00ff41;
            --deep-space: #0a0e27;
            --panel-bg: rgba(13, 20, 58, 0.85);
            --neon-blue: #00d4ff;
            --neon-purple: #b44dff;
            --gold: #ffd700;
            --red: #ff4b2b;
            --dim: rgba(0,255,65,0.35);
            --border: rgba(0,255,65,0.25);
        }
        * { box-sizing: border-box; }
        body {
            background: var(--deep-space);
            color: var(--matrix-green);
            font-family: 'Courier New', Courier, monospace;
            margin: 0; padding: 8px;
            overflow-x: hidden;
            font-size: 13px;
        }
        /* ── Navigation Tabs ── */
        .nav-tabs {
            display: flex; gap: 4px; flex-wrap: wrap;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 6px;
        }
        .nav-tab {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--dim);
            padding: 6px 14px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-radius: 4px 4px 0 0;
            transition: all 0.2s;
        }
        .nav-tab:hover { color: var(--matrix-green); border-color: var(--matrix-green); }
        .nav-tab.active {
            color: var(--gold);
            border-color: var(--gold);
            background: rgba(255,215,0,0.08);
        }
        .tab-page { display: none; }
        .tab-page.active { display: block; }

        /* ── Grid ── */
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 10px;
            max-width: 1600px;
            margin: 0 auto;
        }
        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 0 12px rgba(0,255,65,0.06);
            overflow: hidden;
        }
        .panel.wide { grid-column: 1 / -1; }
        .panel.span2 { grid-column: span 2; }
        h2, h3 {
            margin: 0 0 8px 0;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-size: 0.8rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 4px;
            color: var(--neon-blue);
        }

        /* ── Metrics ── */
        .metrics-row {
            display: flex; flex-wrap: wrap; gap: 8px;
            margin-bottom: 8px;
        }
        .metric {
            flex: 1 1 100px;
            text-align: center;
            padding: 8px 4px;
            background: rgba(0,255,65,0.04);
            border-radius: 4px;
            border: 1px solid rgba(0,255,65,0.1);
        }
        .metric-label { font-size: 0.65rem; color: var(--neon-blue); margin-bottom: 2px; }
        .metric-value { font-size: 1.3rem; font-weight: bold; }
        .metric-value.good { color: var(--matrix-green); }
        .metric-value.warn { color: var(--gold); }
        .metric-value.bad { color: var(--red); }

        /* ── Consciousness State ── */
        .consciousness-state {
            text-align: center; font-weight: bold;
            padding: 6px; border: 2px solid; border-radius: 4px;
            animation: pulse 2s infinite;
            font-size: 0.85rem;
        }
        @keyframes pulse { 0%,100%{opacity:0.7} 50%{opacity:1} }
        .chaos { border-color: var(--red); color: var(--red); }
        .critical { border-color: var(--gold); color: var(--gold); }
        .ordered { border-color: var(--matrix-green); color: var(--matrix-green); }

        /* ── Tables ── */
        .data-table {
            width: 100%; border-collapse: collapse;
            font-size: 0.75rem;
        }
        .data-table th {
            text-align: left; padding: 4px 6px;
            border-bottom: 1px solid var(--border);
            color: var(--neon-blue);
            font-weight: normal;
            text-transform: uppercase;
            font-size: 0.65rem;
        }
        .data-table td {
            padding: 3px 6px;
            border-bottom: 1px solid rgba(0,255,65,0.06);
        }
        .data-table tr:hover td { background: rgba(0,255,65,0.04); }

        /* ── Scrollable containers ── */
        .scroll-box {
            max-height: 220px;
            overflow-y: auto;
            border: 1px solid rgba(0,255,65,0.1);
            border-radius: 4px;
            padding: 4px;
        }
        .scroll-box::-webkit-scrollbar { width: 4px; }
        .scroll-box::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

        /* ── Symbol Grid ── */
        .symbol-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(95px, 1fr));
            gap: 4px;
            max-height: 250px;
            overflow-y: auto;
        }
        .symbol-card {
            font-size: 0.7rem;
            padding: 4px;
            border: 1px solid var(--border);
            border-radius: 3px;
            text-align: center;
        }
        .symbol-card .sym { font-weight: bold; color: var(--gold); }
        .symbol-card .price { color: var(--matrix-green); }
        .symbol-card .acc { font-size: 0.6rem; color: var(--dim); }

        /* ── Canvas ── */
        #coherenceCanvas {
            width: 100%; height: 280px;
            background: #000; border-radius: 4px;
        }

        /* ── Toggles ── */
        .toggle-row {
            display: flex; align-items: center; justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(0,255,65,0.06);
        }
        .toggle-label { font-size: 0.75rem; }
        .toggle-switch {
            position: relative; width: 36px; height: 18px;
            background: rgba(255,75,43,0.3);
            border-radius: 9px; cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-switch.on { background: rgba(0,255,65,0.4); }
        .toggle-switch::after {
            content: ''; position: absolute;
            width: 14px; height: 14px;
            background: var(--matrix-green);
            border-radius: 50%;
            top: 2px; left: 2px;
            transition: left 0.3s;
        }
        .toggle-switch.on::after { left: 20px; }
        select.toggle-select, input.toggle-input {
            background: #000; color: var(--matrix-green);
            border: 1px solid var(--border);
            padding: 3px 6px; font-family: inherit;
            font-size: 0.75rem; border-radius: 3px;
        }

        /* ── Mini bar chart ── */
        .bar-chart { display: flex; align-items: flex-end; gap: 2px; height: 60px; }
        .bar {
            flex: 1; background: var(--matrix-green);
            border-radius: 2px 2px 0 0;
            min-width: 4px;
            transition: height 0.3s;
            position: relative;
        }
        .bar.negative { background: var(--red); }

        /* ── Log entries ── */
        .log-entry {
            font-size: 0.7rem;
            padding: 3px 4px;
            border-bottom: 1px solid rgba(0,255,65,0.04);
            line-height: 1.3;
        }
        .log-entry .ts { color: var(--dim); margin-right: 6px; }

        /* ── Chat ── */
        .chat-container { display: flex; flex-direction: column; height: 280px; }
        .chat-messages {
            flex-grow: 1; overflow-y: auto; padding: 8px;
            border: 1px solid var(--border);
            margin-bottom: 6px;
            background: rgba(0,0,0,0.3);
        }
        .chat-message { margin-bottom: 8px; padding: 6px; border-radius: 4px; line-height: 1.3; font-size: 0.8rem; }
        .user-message { border-left: 3px solid var(--neon-blue); }
        .ai-message { border-left: 3px solid var(--gold); }
        .chat-input-area { display: flex; gap: 6px; }
        .chat-input {
            flex-grow: 1; background: #000;
            border: 1px solid var(--border);
            color: var(--matrix-green);
            padding: 8px; font-family: inherit;
        }
        .chat-send {
            background: var(--matrix-green); color: #000;
            border: none; padding: 0 16px;
            cursor: pointer; font-weight: bold;
            font-family: inherit;
        }

        /* ── Responsive ── */
        @media (max-width: 768px) {
            .dashboard { grid-template-columns: 1fr; }
            .panel.span2 { grid-column: span 1; }
            .metric-value { font-size: 1rem; }
            #coherenceCanvas { height: 180px; }
        }
    </style>
</head>
<body>

<!-- ═══ Navigation ═══ -->
<div class="nav-tabs">
    <button class="nav-tab active" data-tab="overview">Overview</button>
    <button class="nav-tab" data-tab="predictions">Predictions</button>
    <button class="nav-tab" data-tab="learning">Learning</button>
    <button class="nav-tab" data-tab="reasoning">Reasoning</button>
    <button class="nav-tab" data-tab="crossdomain">Cross-Domain</button>
    <button class="nav-tab" data-tab="causal">Causal</button>
    <button class="nav-tab" data-tab="goals">Goals</button>
    <button class="nav-tab" data-tab="providers">Providers</button>
    <button class="nav-tab" data-tab="toggles">Toggles</button>
    <button class="nav-tab" data-tab="chat">Chat</button>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- TAB: Overview                               -->
<!-- ═══════════════════════════════════════════ -->
<div id="tab-overview" class="tab-page active">
<div class="dashboard">
    <!-- Core Metrics -->
    <div class="panel span2">
        <h2>Market Consciousness Monitor</h2>
        <div class="metrics-row">
            <div class="metric"><div class="metric-label">PHI Coherence</div><div class="metric-value" id="mPhi">0.00</div></div>
            <div class="metric"><div class="metric-label">SIGMA Noise</div><div class="metric-value" id="mSigma">0.00</div></div>
            <div class="metric"><div class="metric-label">Attention Density</div><div class="metric-value" id="mRho">0.00</div></div>
            <div class="metric"><div class="metric-label">Prediction Accuracy</div><div class="metric-value" id="mAccuracy">0.0%</div></div>
        </div>
        <div class="consciousness-state" id="consciousnessState">Awaiting Mesh Activation...</div>
    </div>

    <!-- Coherence Visualization -->
    <div class="panel span2">
        <h2>Coherence/Noise EEG</h2>
        <canvas id="coherenceCanvas"></canvas>
    </div>

    <!-- Symbol Grid -->
    <div class="panel wide">
        <h2>Actively Tracked Symbols</h2>
        <div class="symbol-grid scroll-box" id="symbolGrid">
            <!-- Symbol cards will be inserted here -->
        </div>
    </div>

    <!-- System Log -->
    <div class="panel wide">
        <h2>System Log</h2>
        <div id="systemLog" class="scroll-box"></div>
    </div>
</div>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- TAB: Predictions                            -->
<!-- ═══════════════════════════════════════════ -->
<div id="tab-predictions" class="tab-page">
<div class="dashboard">
    <div class="panel wide">
        <h2>Per-Symbol Performance</h2>
        <div class="scroll-box">
            <table class="data-table" id="symbolPerformanceTable">
                <thead>
                    <tr>
                        <th>Symbol</th>
                        <th>Accuracy</th>
                        <th>Predictions</th>
                        <th>Correct</th>
                        <th>Incorrect</th>
                        <th>Current Trend</th>
                        <th>Momentum (5m)</th>
                        <th>Post-Signal Move %</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Symbol performance data will be inserted here -->
                </tbody>
            </table>
        </div>
    </div>

    <div class="panel wide">
        <h2>Recent Predictions</h2>
        <div class="scroll-box">
            <table class="data-table" id="recentPredictionsTable">
                <thead>
                    <tr>
                        <th>Timestamp</th>
                        <th>Symbol</th>
                        <th>Prediction</th>
                        <th>Price at Pred.</th>
                        <th>Result</th>
                        <th>Price at Val.</th>
                        <th>Validated At</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Recent prediction data will be inserted here -->
                </tbody>
            </table>
        </div>
    </div>
</div>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- TAB: Learning                               -->
<!-- ═══════════════════════════════════════════ -->
<div id="tab-learning" class="tab-page">
<div class="dashboard">
    <div class="panel">
        <h2>Learning Rate (PHI)</h2>
        <div class="bar-chart" id="phiChart"></div>
    </div>
    <div class="panel">
        <h2>Forgetting Rate (SIGMA)</h2>
        <div class="bar-chart" id="sigmaChart"></div>
    </div>
    <div class="panel wide">
        <h2>Learning Curve</h2>
        <div id="learningCurve" class="scroll-box"></div>
    </div>
</div>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- TAB: Reasoning                              -->
<!-- ═══════════════════════════════════════════ -->
<div id="tab-reasoning" class="tab-page">
<div class="dashboard">
    <div class="panel wide">
        <h2>Active Rules</h2>
        <div id="rulesContainer" class="scroll-box"></div>
    </div>
</div>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- TAB: Cross-Domain                           -->
<!-- ═══════════════════════════════════════════ -->
<div id="tab-crossdomain" class="tab-page">
<div class="dashboard">
    <div class="panel wide">
        <h2>Cross-Domain Associations</h2>
        <div id="crossDomainContainer" class="scroll-box"></div>
    </div>
</div>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- TAB: Causal                                 -->
<!-- ═══════════════════════════════════════════ -->
<div id="tab-causal" class="tab-page">
<div class="dashboard">
    <div class="panel wide">
        <h2>Causal Chains</h2>
        <div id="causalContainer" class="scroll-box"></div>
    </div>
</div>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- TAB: Goals                                  -->
<!-- ═══════════════════════════════════════════ -->
<div id="tab-goals" class="tab-page">
<div class="dashboard">
    <div class="panel wide">
        <h2>Goal Hierarchy</h2>
        <div id="goalsContainer" class="scroll-box"></div>
    </div>
</div>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- TAB: Providers                                -->
<!-- ═══════════════════════════════════════════ -->
<div id="tab-providers" class="tab-page">
    <div class="dashboard">
        <div class="panel">
            <h2>Data Providers</h2>
            <table class="data-table" id="providerTable">
                <thead>
                    <tr>
                        <th>Provider</th>
                        <th>State</th>
                        <th>Successes</th>
                        <th>Failures</th>
                        <th>Latency</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Provider data will be inserted here -->
                </tbody>
            </table>
        </div>

        <div class="panel">
            <h2>Scouting Price Filters</h2>
            <div class="toggle-row">
                <label for="minPriceInput" class="toggle-label">Min Price:</label>
                <input type="number" id="minPriceInput" class="toggle-input" value="0.0" step="0.01">
            </div>
            <div class="toggle-row">
                <label for="maxPriceInput" class="toggle-label">Max Price:</label>
                <input type="number" id="maxPriceInput" class="toggle-input" value="Infinity" step="0.01">
            </div>
            <button id="applyPriceFilter" class="nav-tab">Apply Filters</button>
        </div>

        <div class="panel">
            <h2>Orchestrator Status</h2>
            <div id="orchestratorStatus" class="scroll-box"></div>
        </div>
    </div>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- TAB: Toggles                                -->
<!-- ═══════════════════════════════════════════ -->
<div id="tab-toggles" class="tab-page">
<div class="dashboard">
    <div class="panel wide">
        <h2>System Toggles</h2>
        <div id="togglesContainer"></div>
    </div>
</div>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- TAB: Chat                                   -->
<!-- ═══════════════════════════════════════════ -->
<div id="tab-chat" class="tab-page">
<div class="dashboard">
    <div class="panel wide">
        <h2>Chat with Mesh</h2>
        <div class="chat-container">
            <div class="chat-messages scroll-box" id="chatMessages"></div>
            <div class="chat-input-area">
                <input type="text" id="chatInput" class="chat-input" placeholder="Ask about the market...">
                <button id="chatSend" class="chat-send">SEND</button>
            </div>
        </div>
    </div>
</div>
</div>

<script>
// ═════════════════════════════════════════════════════════════════════════════
//
//  MARKET CONSCIOUSNESS MONITOR - Z³ by MANUEL MELLO
//
// ═════════════════════════════════════════════════════════════════════════════

document.addEventListener('DOMContentLoaded', () => {
    const API_BASE = ''; // Assuming the gateway serves this file

    // ─── STATE ───────────────────────────────────────────────────────────────────
    let state = {};
    let activeTab = 'overview';

    // ─── DOM ELEMENTS ────────────────────────────────────────────────────────────
    const tabs = document.querySelectorAll('.nav-tab');
    const pages = document.querySelectorAll('.tab-page');
    const mPhi = document.getElementById('mPhi');
    const mSigma = document.getElementById('mSigma');
    const mRho = document.getElementById('mRho');
    const mAccuracy = document.getElementById('mAccuracy');
    const consciousnessState = document.getElementById('consciousnessState');
    const symbolGrid = document.getElementById('symbolGrid');
    const systemLog = document.getElementById('systemLog');
    const symbolPerformanceTable = document.getElementById('symbolPerformanceTable').getElementsByTagName('tbody')[0];
    const recentPredictionsTable = document.getElementById('recentPredictionsTable').getElementsByTagName('tbody')[0];
    const phiChart = document.getElementById('phiChart');
    const sigmaChart = document.getElementById('sigmaChart');
    const learningCurve = document.getElementById('learningCurve');
    const rulesContainer = document.getElementById('rulesContainer');
    const crossDomainContainer = document.getElementById('crossDomainContainer');
    const causalContainer = document.getElementById('causalContainer');
    const goalsContainer = document.getElementById('goalsContainer');
    const providerTable = document.getElementById('providerTable').getElementsByTagName('tbody')[0];
    const orchestratorStatus = document.getElementById('orchestratorStatus');
    const togglesContainer = document.getElementById('togglesContainer');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const chatSend = document.getElementById("chatSend");

    const minPriceInput = document.getElementById("minPriceInput");
    const maxPriceInput = document.getElementById("maxPriceInput");
    const applyPriceFilter = document.getElementById("applyPriceFilter");

    // ─── CHARTING ────────────────────────────────────────────────────────────────
    const coherenceCanvas = document.getElementById('coherenceCanvas');
    const ctx = coherenceCanvas.getContext('2d');
    let chartData = { theta: [], alpha: [], beta: [], gamma: [] };
    const chartCapacity = 200;

    function drawEEG() {
        const width = coherenceCanvas.width;
        const height = coherenceCanvas.height;
        ctx.clearRect(0, 0, width, height);

        const waveColors = {
            theta: 'rgba(255, 75, 43, 0.8)',
            alpha: 'rgba(255, 215, 0, 0.8)',
            beta: 'rgba(0, 212, 255, 0.8)',
            gamma: 'rgba(0, 255, 65, 0.8)',
        };

        Object.keys(chartData).forEach((wave, waveIndex) => {
            const data = chartData[wave];
            ctx.beginPath();
            ctx.strokeStyle = waveColors[wave];
            ctx.lineWidth = 1.5;

            for (let i = 0; i < data.length; i++) {
                const x = (i / (chartCapacity - 1)) * width;
                const y = (height / 2) - (data[i] * (height / 2.5));
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        });
    }

    // ─── UI UPDATES ──────────────────────────────────────────────────────────────

    function updateMetrics() {
        if (!state.metrics) return;
        mPhi.textContent = state.metrics.phi.toFixed(4);
        mSigma.textContent = state.metrics.sigma.toFixed(4);
        mRho.textContent = state.metrics.rho.toFixed(4);
        mAccuracy.textContent = `${(state.metrics.accuracy * 100).toFixed(1)}%`;

        consciousnessState.textContent = state.metrics.consciousness_state;
        consciousnessState.className = 'consciousness-state ' + state.metrics.consciousness_state.toLowerCase();
    }

    function updateSymbolGrid() {
        if (!state.insights || !state.insights.symbol_perf) return;
        symbolGrid.innerHTML = '';
        Object.entries(state.insights.symbol_perf).forEach(([symbol, perf]) => {
            const card = document.createElement('div');
            card.className = 'symbol-card';
            card.innerHTML = `
                <div class="sym">${symbol}</div>
                <div class="price">${perf.current_price.toFixed(4)}</div>
                <div class="acc">${(perf.accuracy * 100).toFixed(0)}%</div>
            `;
            symbolGrid.appendChild(card);
        });
    }

    function updateSystemLog() {
        if (!state.log) return;
        systemLog.innerHTML = '';
        state.log.forEach(entry => {
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `<span class="ts">${new Date(entry.timestamp).toLocaleTimeString()}</span> ${entry.message}`;
            systemLog.appendChild(logEntry);
        });
        systemLog.scrollTop = systemLog.scrollHeight;
    }

    function updateSymbolPerformance() {
        if (!state.insights || !state.insights.symbol_perf) return;
        symbolPerformanceTable.innerHTML = '';
        Object.entries(state.insights.symbol_perf).forEach(([symbol, perf]) => {
            const row = symbolPerformanceTable.insertRow();
            row.innerHTML = `
                <td>${symbol}</td>
                <td>${(perf.accuracy * 100).toFixed(1)}%</td>
                <td>${perf.total_predictions}</td>
                <td>${perf.correct_predictions}</td>
                <td>${perf.incorrect_predictions}</td>
                <td>${perf.current_trend}</td>
                <td>${perf.momentum_5m.toFixed(2)}%</td>
                <td>${(perf.max_post_signal_move_pct * 100).toFixed(2)}%</td>
            `;
        });
    }

    function updateRecentPredictions() {
        if (!state.insights || !state.insights.recent_preds) return;
        recentPredictionsTable.innerHTML = '';
        state.insights.recent_preds.forEach(pred => {
            const row = recentPredictionsTable.insertRow();
            const result = pred.correct === null ? 'Pending' : (pred.correct ? '✅' : '❌');
            row.innerHTML = `
                <td>${new Date(pred.timestamp).toLocaleString()}</td>
                <td>${pred.symbol}</td>
                <td>${pred.predicted_direction}</td>
                <td>${pred.price_at_prediction.toFixed(4)}</td>
                <td>${result}</td>
                <td>${pred.price_at_validation ? pred.price_at_validation.toFixed(4) : 'N/A'}</td>
                <td>${pred.validated_at ? new Date(pred.validated_at).toLocaleString() : 'N/A'}</td>
            `;
        });
    }

    function updateLearningCharts() {
        if (!state.metrics) return;
        // This is a simplified visualization. A real implementation might use a library.
        phiChart.innerHTML = `<div class="bar" style="height: ${state.metrics.phi * 100}%"></div>`;
        sigmaChart.innerHTML = `<div class="bar negative" style="height: ${state.metrics.sigma * 100}%"></div>`;
    }

    function updateLearningCurve() {
        if (!state.insights || !state.insights.learning_curve) return;
        learningCurve.innerHTML = '';
        state.insights.learning_curve.forEach(point => {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `Cycle ${point.cycle}: Accuracy = ${(point.accuracy * 100).toFixed(2)}%`;
            learningCurve.appendChild(entry);
        });
    }

    function updateRules() {
        if (!state.reasoning || !state.reasoning.rules) return;
        rulesContainer.innerHTML = '';
        state.reasoning.rules.forEach(rule => {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${rule.type}] ${rule.description} (Weight: ${rule.weight.toFixed(3)})`;
            rulesContainer.appendChild(entry);
        });
    }

    function updateCrossDomain() {
        if (!state.reasoning || !state.reasoning.cross_domain) return;
        crossDomainContainer.innerHTML = '';
        state.reasoning.cross_domain.forEach(assoc => {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `(${assoc.source_domain}) -> (${assoc.target_domain}): ${assoc.description} | Strength: ${assoc.strength.toFixed(3)}`;
            crossDomainContainer.appendChild(entry);
        });
    }

    function updateCausal() {
        if (!state.reasoning || !state.reasoning.causal_chains) return;
        causalContainer.innerHTML = '';
        state.reasoning.causal_chains.forEach(chain => {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `${chain.nodes.join(' -> ')} | Confidence: ${chain.confidence.toFixed(3)}`;
            causalContainer.appendChild(entry);
        });
    }

    function updateGoals() {
        if (!state.reasoning || !state.reasoning.goals) return;
        goalsContainer.innerHTML = '';
        state.reasoning.goals.forEach(goal => {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${goal.status}] ${goal.name}: ${goal.description} | Priority: ${goal.priority}`;
            goalsContainer.appendChild(entry);
        });
    }

    function updateProviders() {
        if (!state.providers) return;
        providerTable.innerHTML = '';
        Object.entries(state.providers).forEach(([name, status]) => {
            const row = providerTable.insertRow();
            row.innerHTML = `
                <td>${name}</td>
                <td>${status.state}</td>
                <td>${status.successes}</td>
                <td>${status.failures}</td>
                <td>${status.avg_latency_ms.toFixed(2)}ms</td>
            `;
        });
    }

    function updateOrchestrator() {
        if (!state.orchestrator) return;
        orchestratorStatus.innerHTML = '';
        state.orchestrator.tasks.forEach(task => {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${task.status}] ${task.name} - Next run: ${new Date(task.next_run).toLocaleString()}`;
            orchestratorStatus.appendChild(entry);
        });
    }

    function updateToggles() {
        if (!state.toggles) return;
        togglesContainer.innerHTML = '';
        Object.entries(state.toggles).forEach(([key, value]) => {
            const row = document.createElement('div');
            row.className = 'toggle-row';

            if (typeof value === 'boolean') {
                row.innerHTML = `
                    <span class="toggle-label">${key}</span>
                    <div class="toggle-switch ${value ? 'on' : ''}" data-key="${key}"></div>
                `;
            } else if (Array.isArray(value.options)) {
                row.innerHTML = `
                    <label for="toggle-${key}" class="toggle-label">${key}</label>
                    <select id="toggle-${key}" class="toggle-select" data-key="${key}">
                        ${value.options.map(opt => `<option value="${opt}" ${opt === value.current ? 'selected' : ''}>${opt}</option>`).join('')}
                    </select>
                `;
            }
            togglesContainer.appendChild(row);
        });
    }

    // ─── DATA FETCHING ───────────────────────────────────────────────────────────

    async function fetchState() {
        try {
            const response = await fetch(`${API_BASE}/api/state`);
            if (!response.ok) {
                console.error('Failed to fetch state:', response.status);
                return;
            }
            state = await response.json();
            updateAllTabs();
        } catch (error) {
            console.error('Error fetching state:', error);
        }
    }

    async function fetchEEG() {
        try {
            const response = await fetch(`${API_BASE}/api/eeg`);
            if (!response.ok) {
                console.error('Failed to fetch EEG data:', response.status);
                return;
            }
            const eegData = await response.json();
            Object.keys(eegData).forEach(wave => {
                if (chartData[wave]) {
                    chartData[wave].push(eegData[wave]);
                    if (chartData[wave].length > chartCapacity) {
                        chartData[wave].shift();
                    }
                }
            });
            // Throttle drawing to prevent performance issues
            requestAnimationFrame(drawEEG);
        } catch (error) {
            console.error('Error fetching EEG data:', error);
        }
    }

    async function postToggle(key, value) {
        try {
            await fetch(`${API_BASE}/api/toggles`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ [key]: value })
            });
            // Fetch state again to reflect the change immediately
            fetchState();
        } catch (error) {
            console.error('Error posting toggle:', error);
        }
    }

    async function postPriceFilters(minPrice, maxPrice) {
        try {
            await fetch(`${API_BASE}/api/price_filters`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ min_price: parseFloat(minPrice), max_price: parseFloat(maxPrice) })
            });
            fetchState(); // Refresh state to reflect new filters
        } catch (error) {
            console.error('Error posting price filters:', error);
        }
    }

    async function postChatMessage(message) {
        try {
            const response = await fetch(`${API_BASE}/api/chat`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: message })
            });
            const data = await response.json();
            appendChatMessage('user', message);
            appendChatMessage('ai', data.reply);
        } catch (error) {
            console.error('Error sending chat message:', error);
        }
    }

    function appendChatMessage(sender, text) {
        const messageEl = document.createElement('div');
        messageEl.className = `chat-message ${sender}-message`;
        messageEl.textContent = text;
        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // ─── EVENT LISTENERS ─────────────────────────────────────────────────────────

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const tabName = tab.dataset.tab;
            if (tabName === activeTab) return;

            tabs.forEach(t => t.classList.remove('active'));
            pages.forEach(p => p.classList.remove('active'));

            tab.classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');
            activeTab = tabName;
            updateAllTabs(); // Refresh data when switching tabs
        });
    });

    togglesContainer.addEventListener('click', e => {
        if (e.target.classList.contains('toggle-switch')) {
            const key = e.target.dataset.key;
            const newValue = !e.target.classList.contains('on');
            postToggle(key, newValue);
        }
    });

    togglesContainer.addEventListener('change', e => {
        if (e.target.classList.contains('toggle-select')) {
            const key = e.target.dataset.key;
            const newValue = e.target.value;
            postToggle(key, newValue);
        }
    });

    chatSend.addEventListener('click', () => {
        const message = chatInput.value.trim();
        if (message) {
            postChatMessage(message);
            chatInput.value = '';
        }
    });

    chatInput.addEventListener("keydown", e => {
        if (e.key === "Enter") {
            chatSend.click();
        }
    });

    applyPriceFilter.addEventListener("click", () => {
        const minPrice = minPriceInput.value;
        const maxPrice = maxPriceInput.value;
        postPriceFilters(minPrice, maxPrice);
    });

    // ─── INITIALIZATION ──────────────────────────────────────────────────────────

    function updateAllTabs() {
        updateMetrics();
        switch (activeTab) {
            case 'overview':
                updateSymbolGrid();
                updateSystemLog();
                break;
            case 'predictions':
                updateSymbolPerformance();
                updateRecentPredictions();
                break;
            case 'learning':
                updateLearningCharts();
                updateLearningCurve();
                break;
            case 'reasoning':
                updateRules();
                break;
            case 'crossdomain':
                updateCrossDomain();
                break;
            case 'causal':
                updateCausal();
                break;
            case 'goals':
                updateGoals();
                break;
            case 'providers':
                updateProviders();
                updateOrchestrator();
                break;
            case 'toggles':
                updateToggles();
                break;
        }
    }

    // Initial fetch and setup intervals
    fetchState();
    fetchEEG();
    setInterval(fetchState, 2000); // Main state update every 2s
    setInterval(fetchEEG, 500);   // EEG update every 500ms

    // Initial drawing of the canvas
    drawEEG();
});
</script>
</body>
</html>
